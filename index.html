<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Mouse-Driven Particle Text Transition</title>
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      background: white;
      font-family: Satoshi, Arial, sans-serif;
    }
    canvas {
      display: block;
    }
    #controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 8px;
      font-size: 14px;
      pointer-events: none; /* Prevent controls from blocking mouse events */
    }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="controls">
  Move your mouse through the text to trigger transitions
</div>

<script>
// Add easing functions for more graceful transitions
const easingFunctions = {
  // Cubic easing out - decelerating to zero velocity
  easeOutCubic: t => 1 - Math.pow(1 - t, 3),
  // Quintic easing in-out - acceleration until halfway, then deceleration
  easeInOutQuint: t => t < 0.5 ? 24 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2,
  // Elastic effect - bouncy movement
  easeOutElastic: t => {
    const c4 = (2 * Math.PI) / 3;
    return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
  },
  // Sinusoidal smooth movement
  easeInOutSine: t => -(Math.cos(Math.PI * t) - 1) / 2
};

const config = {
  velocityDamping: 0.80,
  homingStrength: 0.012,
  wanderingIntensity: 0.08,
  mouseRadiusMin: 10,       // Minimum mouse radius
  mouseRadiusMax: 120,      // Maximum mouse radius
  mouseRadiusDefault: 100,  // Default radius (used when mouse is not on screen)
  mouseProximityRange: 300, // How far from center the radius starts scaling
  repulsionForce: 12,
  fontSize: 64,
  pointSpacing: 4,
  lineHeight: 70,
  transitionSpeed: 0.5, // Slightly slowed down for more fluid motion
  arcFactor: 0.02, // Reduced slightly for more natural arcs
  textPhrases: ["Are you creating\n new possibilities or \nefficiently executing within\nestablished boundaries?", "This is just\na test to see\nif this works", "we need to\nkeep our time\nvery precious", "Dynamic Text\ncan be great\nif you talk", "You migh\njust need to\nstop trying so hard."],
  mouseTransitionThreshold: 350, // Reduced threshold for easier triggering
  transitionCooldown: 3000,
  mouseExposureDecay: 0.3,
  stabilityThreshold: 5,
  stableWanderingFactor: 0.1,
  easingFunction: "easeInOutSine", // Default easing function
  pathType: "figure8",        // NEW: Default path type set to figure8
  colorTransition: true,      // Enable color transitions
  groupTransition: true,      // Enable group-based transitions
  transitionGroups: 5,        // Number of particle groups for staggered transitions
  maxPathRandomization: 0.3,  // Maximum randomization for particle paths
  minParticleSize: 1,         // Minimum size for unused particles
  maxParticleSize: 3,         // Maximum size for active particles
  sizeTransitionSpeed: 0.05,  // How quickly particles change size
  randomizeActiveParticleSize: true,  // Enable random sizes for active particles
  figure8Size: 50,           // NEW: Size of the figure-8 loops
  figure8Variation: true,    // NEW: Randomize figure-8 properties per particle
  wiggleEnabled: true,       // Enable wiggle effect during transition
  wiggleFrequency: 0.3,      // Frequency of wiggle oscillation
  wiggleAmplitude: 5,        // Maximum amplitude of wiggle
  wiggleProgressFactor: 1.5   // Controls wiggle peak timing
};

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let particles = [];
let mouse = {
  x: null,
  y: null,
  radius: config.mouseRadiusDefault
};
let currentPhraseIndex = 0;
let nextPhraseIndex = 1;
let transitionProgress = 0;
let isTransitioning = false;
let lastTransitionTime = 0;
let affectedParticlesCount = 0;
let colorSchemes = [
  { base: [255, 0, 100], active: [255, 50, 150] },     // Neon red to hot pink
  { base: [200, 0, 255], active: [255, 100, 255] },    // Electric purple to bright magenta
  { base: [255, 20, 200], active: [255, 100, 255] },   // Hot pink to electric magenta
  { base: [150, 0, 200], active: [170, 255, 0] },      // Deep purple to neon lime (af0)
  { base: [255, 0, 150], active: [255, 80, 200] },     // Electric pink to neon magenta
  { base: [200, 50, 255], active: [255, 150, 255] },   // Bright purple to electric pink
  { base: [180, 0, 120], active: [170, 255, 0] },      // Purple-red to neon lime (af0)
  { base: [255, 30, 80], active: [255, 100, 180] }     // Neon red to bright pink
];
let currentColorScheme = 0;
let nextColorScheme = 0;

// Add text center tracking
let textCenter = { x: 0, y: 0 };

// Cache for target points
const cachedTargetPoints = {};

class Particle {
  constructor(homeX, homeY, nextHomeX, nextHomeY) {
    this.homeX = homeX;
    this.homeY = homeY;
    this.nextHomeX = nextHomeX || homeX;
    this.nextHomeY = nextHomeY || homeY;
    this.x = Math.random() * canvas.width;
    this.y = Math.random() * canvas.height;
    this.vx = 0;
    this.vy = 0;
    this.opacity = 1;  // Full by default
    this.isActive = true; // Whether it should be visible
    this.targetSize = config.maxParticleSize;
    this.size = Math.random() * (config.maxParticleSize - config.minParticleSize) + config.minParticleSize;
    this.t = Math.random() * 2000;
    this.transitionDelay = Math.random() * 0.5;
    this.individualProgress = 0;
    this.arcHeight = (Math.random() * 0.5 + 0.5) * 200;
    this.arcDirection = Math.random() > 0.5 ? 1 : -1;
    this.mouseExposure = 0;
    this.isAffectedByMouse = false;
    this.transitionGroup = Math.floor(Math.random() * config.transitionGroups); // Assign to a transition group

    // Path type options now include figure8
    this.pathType = "figure8"; // Set default to figure8

    // For bezier paths (if used)
    this.bezierControlPoint1 = {
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height
    };
    this.bezierControlPoint2 = {
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height
    };

    // NEW: Figure-8 properties
    this.figure8Size = config.figure8Size * (0.5 + Math.random() * 0.5); // Random size multiplier
    this.figure8Angle = Math.random() * Math.PI * 2; // Random orientation of figure 8
    this.figure8Direction = Math.random() > 0.5 ? 1 : -1; // Random direction

    this.pathRandomization = Math.random() * config.maxPathRandomization;
    this.baseColor = [...colorSchemes[currentColorScheme].base];
    this.activeColor = [...colorSchemes[currentColorScheme].active];
    this.nextBaseColor = [...colorSchemes[nextColorScheme].base];
    this.nextActiveColor = [...colorSchemes[nextColorScheme].active];
    this.isUsedInCurrentPhrase = true;
    this.isUsedInNextPhrase = true;
    this.randomSizeAssigned = false; // Track if this particle has been assigned a random size

    // Wiggle properties
    this.wigglePhaseOffset = Math.random() * Math.PI * 2; // Random starting phase
    this.wiggleDirection = Math.random() * Math.PI * 2;   // Random wiggle direction
    this.wiggleFactor = 0.5 + Math.random();              // Randomize wiggle intensity per particle
  }

  draw() {
    // Only draw if particle is reasonably within view
    if (this.x < -mouse.radius * 2 || this.x > canvas.width + this.size * 2 || this.y < -this.size * 2 || this.y > canvas.height + this.size * 2) {
        return;
    }

    const distToTarget = Math.sqrt(
      Math.pow(this.x - (this.individualProgress > 0 ? this.nextHomeX : this.homeX), 2) +
      Math.pow(this.y - (this.individualProgress > 0 ? this.nextHomeY : this.homeY), 2)
    );

    const alpha = Math.min(1, 3 / (1 + distToTarget * 0.05));

    // Calculate color based on mouse exposure and transition progress
    let r, g, b;

    if (config.colorTransition && isTransitioning) {
      // Interpolate between current and next color schemes
      const baseR = this.baseColor[0] + (this.nextBaseColor[0] - this.baseColor[0]) * this.individualProgress;
      const baseG = this.baseColor[1] + (this.nextBaseColor[1] - this.baseColor[1]) * this.individualProgress;
      const baseB = this.baseColor[2] + (this.nextBaseColor[2] - this.baseColor[2]) * this.individualProgress;

      const activeR = this.activeColor[0] + (this.nextActiveColor[0] - this.activeColor[0]) * this.individualProgress;
      const activeG = this.activeColor[1] + (this.nextActiveColor[1] - this.activeColor[1]) * this.individualProgress;
      const activeB = this.activeColor[2] + (this.nextActiveColor[2] - this.activeColor[2]) * this.individualProgress;

      r = baseR + (activeR - baseR) * this.mouseExposure;
      g = baseG + (activeG - baseG) * this.mouseExposure;
      b = baseB + (activeB - baseB) * this.mouseExposure;
    } else {
      // Just use the current color scheme
      r = this.baseColor[0] + (this.activeColor[0] - this.baseColor[0]) * this.mouseExposure;
      g = this.baseColor[1] + (this.activeColor[1] - this.baseColor[1]) * this.mouseExposure;
      b = this.baseColor[2] + (this.activeColor[2] - this.baseColor[2]) * this.mouseExposure;
    }

    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
    ctx.fill();
  }

  update() {
    this.t += 1;
    this.isAffectedByMouse = false;

    this.mouseExposure *= config.mouseExposureDecay;

    // Update particle size based on whether it's used in current or next phrase
    let currentFrameTargetSize;
    if (isTransitioning) {
      // During transition, interpolate size based on usage in next phrase
      if (this.isUsedInNextPhrase) {
        if (config.randomizeActiveParticleSize && !this.randomSizeAssigned) {
          this.targetSize = Math.random() * (config.maxParticleSize - config.minParticleSize) + config.minParticleSize;
          this.randomSizeAssigned = true;
        } else if (!config.randomizeActiveParticleSize) {
          this.targetSize = config.maxParticleSize;
        }
      } else {
        this.targetSize = config.minParticleSize;
        this.randomSizeAssigned = false;
      }

      // FIXED: Interpolate size based on transition progress
      // Get the size the particle should be at its current position in the transition
      const currentSize = this.isUsedInCurrentPhrase ?
        (config.randomizeActiveParticleSize ? this.size : config.maxParticleSize) :
        config.minParticleSize;

      // Interpolate between current size and target size based on individual progress
      currentFrameTargetSize = currentSize + (this.targetSize - currentSize) * this.individualProgress;

    } else {
      // Not in transition, size based on current phrase usage
      if (this.isUsedInCurrentPhrase) {
        if (config.randomizeActiveParticleSize && !this.randomSizeAssigned) {
          this.targetSize = Math.random() * (config.maxParticleSize - config.minParticleSize) + config.minParticleSize;
          this.randomSizeAssigned = true;
        } else if (!config.randomizeActiveParticleSize) {
          this.targetSize = config.maxParticleSize;
        }
      } else {
        this.targetSize = config.minParticleSize;
        this.randomSizeAssigned = false;
      }
      currentFrameTargetSize = this.targetSize;
    }

    // Smoothly transition size to current frame target
    if (isTransitioning) {
      // During transition, size changes with position
      this.size = currentFrameTargetSize;
    } else {
      // When not transitioning, gradually approach target size
      if (this.size < currentFrameTargetSize) {
        this.size += config.sizeTransitionSpeed;
        if (this.size > currentFrameTargetSize) this.size = currentFrameTargetSize;
      } else if (this.size > currentFrameTargetSize) {
        this.size -= config.sizeTransitionSpeed;
        if (this.size < currentFrameTargetSize) this.size = currentFrameTargetSize;
      }
    }

    if (isTransitioning && this.individualProgress < 1) {
      const speedMultiplier = 1 + this.mouseExposure * 2;

      // Apply group-based transition delay
      let groupDelay = 0;
      if (config.groupTransition) {
        groupDelay = this.transitionGroup * 0.1; // Each group is delayed by 0.1
      }

      if (transitionProgress > this.transitionDelay + groupDelay) {
        this.individualProgress += config.transitionSpeed * speedMultiplier;
        if (this.individualProgress > 1) this.individualProgress = 1;
      }
    } else if (!isTransitioning) {
      this.individualProgress = 0;
    }

    let targetX, targetY;
    if (this.individualProgress > 0) {
      // Apply easing to the progress
      const easedProgress = easingFunctions[config.easingFunction](this.individualProgress);

      // Calculate position based on path type
      if (this.pathType === "bezier") {
        // Bezier curve path
        targetX = this.getBezierPoint(
          this.homeX,
          this.bezierControlPoint1.x + (this.bezierControlPoint1.x * this.pathRandomization),
          this.bezierControlPoint2.x + (this.bezierControlPoint2.x * this.pathRandomization),
          this.nextHomeX,
          easedProgress
        );
        targetY = this.getBezierPoint(
          this.homeY,
          this.bezierControlPoint1.y + (this.bezierControlPoint1.y * this.pathRandomization),
          this.bezierControlPoint2.y + (this.bezierControlPoint2.y * this.pathRandomization),
          this.nextHomeY,
          easedProgress
        );
      } else if (this.pathType === "arc") {
        // Arc path (original implementation)
        targetX = this.homeX + (this.nextHomeX - this.homeX) * easedProgress;
        const arcOffset = Math.sin(easedProgress * Math.PI) * this.arcHeight * config.arcFactor;
        targetY = this.homeY + (this.nextHomeY - this.homeY) * easedProgress +
                  arcOffset * this.arcDirection;
      } else if (this.pathType === "figure8") {
        // NEW: Figure-8 path implementation
        // Get the direct path as the center of the figure 8
        const directX = this.homeX + (this.nextHomeX - this.homeX) * easedProgress;
        const directY = this.homeY + (this.nextHomeY - this.homeY) * easedProgress;

        // Calculate distance between start and end points
        const dx = this.nextHomeX - this.homeX;
        const dy = this.nextHomeY - this.homeY;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Scale figure8Size based on distance
        const adjustedSize = Math.min(this.figure8Size, distance * 0.4);

        // Calculate angle of direction from start to end
        const angle = Math.atan2(dy, dx);

        // Create a parametric figure-8 path
        // t goes from 0 to 2Ï€ as progress goes from 0 to 1
        const t = easedProgress * Math.PI * 2;

        // Figure-8 formula (lemniscate of Bernoulli)
        const figure8X = adjustedSize * Math.sin(t) / (1 + Math.pow(Math.cos(t), 2));
        const figure8Y = adjustedSize * Math.sin(t) * Math.cos(t) / (1 + Math.pow(Math.cos(t), 2));

        // Rotate the figure-8 to align with the path direction
        const rotatedX = figure8X * Math.cos(angle) - figure8Y * Math.sin(angle);
        const rotatedY = figure8X * Math.sin(angle) + figure8Y * Math.cos(angle);

        // Apply the figure-8 offset to the direct path
        targetX = directX + rotatedX * this.figure8Direction;
        targetY = directY + rotatedY * this.figure8Direction;
      }

      // Apply wiggle effect during transition
      if (config.wiggleEnabled && this.isUsedInNextPhrase) {
        // Create a wiggle that peaks in the middle of the transition
        const wiggleProgress = Math.sin(easedProgress * Math.PI * config.wiggleProgressFactor);

        // Calculate wiggle offset using sine wave with particle-specific phase
        const wiggleTime = this.t * config.wiggleFrequency + this.wigglePhaseOffset;
        const wiggleAmount = Math.sin(wiggleTime) * config.wiggleAmplitude * wiggleProgress * this.wiggleFactor;

        // Apply wiggle in random direction
        targetX += Math.cos(this.wiggleDirection) * wiggleAmount;
        targetY += Math.sin(this.wiggleDirection) * wiggleAmount;
      }
    } else {
      targetX = this.homeX;
      targetY = this.homeY;
    }

    const dx = targetX - this.x;
    const dy = targetY - this.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    const isStable = dist < config.stabilityThreshold;

    const strength = config.homingStrength * (1 + dist / 500);
    this.vx += dx * strength;
    this.vy += dy * strength;

    const wanderingScale = isStable ? config.stableWanderingFactor : 1;
    this.vx += Math.sin(this.t * 0.08 + this.x * 0.01) * config.wanderingIntensity * wanderingScale;
    this.vy += Math.cos(this.t * 0.08 + this.y * 0.01) * config.wanderingIntensity * wanderingScale;

    if (typeof mouse.x === "number" && typeof mouse.y === "number") {
      const dxMouse = mouse.x - this.x;
      const dyMouse = mouse.y - this.y;
      const distMouse = Math.sqrt(dxMouse * dxMouse + dyMouse * dyMouse);

      // Get current mouse radius (may change based on position)
      const currentMouseRadius = mouse.radius;

      if (distMouse < currentMouseRadius) {
        this.isAffectedByMouse = true;
        this.mouseExposure += 0.1;
        if (this.mouseExposure > 1) this.mouseExposure = 1;

        const angle = Math.atan2(dyMouse, dxMouse);
        const force = (currentMouseRadius - distMouse) / currentMouseRadius;

        this.vx -= Math.cos(angle) * force * config.repulsionForce;
        this.vy -= Math.sin(angle) * force * config.repulsionForce;

        this.vx += Math.sin(angle) * force * config.repulsionForce * 0.6;
        this.vy -= Math.cos(angle) * force * config.repulsionForce * 0.6;
      }
    }

    const dampingFactor = isStable ? 0.92 : config.velocityDamping;
    this.vx *= dampingFactor;
    this.vy *= dampingFactor;
    this.x += this.vx;
    this.y += this.vy;

    this.draw();
  }

  // Cubic Bezier calculation
  getBezierPoint(p0, p1, p2, p3, t) {
    return Math.pow(1-t, 3) * p0 +
           3 * Math.pow(1-t, 2) * t * p1 +
           3 * (1-t) * Math.pow(t, 2) * p2 +
           Math.pow(t, 3) * p3;
  }

  setNextPosition(x, y) {
    this.nextHomeX = x;
    this.nextHomeY = y;
  }

  setNextColors(baseColor, activeColor) {
    this.nextBaseColor = baseColor;
    this.nextActiveColor = activeColor;
  }

  commitTransition() {
    this.homeX = this.nextHomeX;
    this.homeY = this.nextHomeY;
    this.baseColor = [...this.nextBaseColor];
    this.activeColor = [...this.nextActiveColor];
    this.individualProgress = 0;
    this.transitionDelay = Math.random() * 0.5;
    this.arcHeight = (Math.random() * 0.5 + 0.5) * 200;
    this.arcDirection = Math.random() > 0.5 ? 1 : -1;

    // Update path properties
    if (config.figure8Variation) {
      this.figure8Size = config.figure8Size * (0.5 + Math.random() * 0.5);
      this.figure8Angle = Math.random() * Math.PI * 2;
      this.figure8Direction = Math.random() > 0.5 ? 1 : -1;
    }

    this.bezierControlPoint1 = {
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height
    };
    this.bezierControlPoint2 = {
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height
    };
    this.pathRandomization = Math.random() * config.maxPathRandomization;
    this.transitionGroup = Math.floor(Math.random() * config.transitionGroups);
    this.randomSizeAssigned = false; // Reset random size flag after transition

    // Update wiggle properties
    this.wigglePhaseOffset = Math.random() * Math.PI * 2;
    this.wiggleDirection = Math.random() * Math.PI * 2;
    this.wiggleFactor = 0.5 + Math.random();

    // Update usage flags after transition
    this.isUsedInCurrentPhrase = this.isUsedInNextPhrase;
  }

  reset() {
      // A general reset for particles that might be re-used
      this.x = Math.random() * canvas.width;
      this.y = Math.random() * canvas.height;
      this.vx = 0;
      this.vy = 0;
      this.t = Math.random() * 1000;
      this.transitionDelay = Math.random() * 0.5;
      this.individualProgress = 0;
      this.arcHeight = (Math.random() * 0.5 + 0.5) * 200;
      this.arcDirection = Math.random() > 0.5 ? 1 : -1;
      this.mouseExposure = 0;
      this.isAffectedByMouse = false;
      this.transitionGroup = Math.floor(Math.random() * config.transitionGroups);

      // Reset path properties
      if (config.figure8Variation) {
        this.figure8Size = config.figure8Size * (0.5 + Math.random() * 0.5);
        this.figure8Angle = Math.random() * Math.PI * 2;
        this.figure8Direction = Math.random() > 0.5 ? 1 : -1;
      }

      this.bezierControlPoint1 = {
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height
      };
      this.bezierControlPoint2 = {
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height
      };
      this.pathRandomization = Math.random() * config.maxPathRandomization;
      this.randomSizeAssigned = false; // Reset random size flag

      // Reset wiggle properties
      this.wigglePhaseOffset = Math.random() * Math.PI * 2;
      this.wiggleDirection = Math.random() * Math.PI * 2;
      this.wiggleFactor = 0.5 + Math.random();
  }
}

function getTargetPoints(text) {
  if (cachedTargetPoints[text]) {
    return cachedTargetPoints[text];
  }

  const offCanvas = document.createElement("canvas");
  const offCtx = offCanvas.getContext("2d");

  offCtx.font = `${config.fontSize}px Arial, sans-serif`;
  offCtx.textBaseline = "top"; // Important for consistent vertical positioning
  offCtx.fillStyle = "black"; // Ensure text is drawn in black for pixel detection

  const lines = text.split('\n');
  let maxWidth = 0;
  // Measure each line to find the maximum width needed for the off-screen canvas
  lines.forEach(line => {
    const lineWidth = offCtx.measureText(line).width;
    if (lineWidth > maxWidth) {
      maxWidth = lineWidth;
    }
  });

  const totalTextHeight = lines.length * config.lineHeight;

  // Set off-screen canvas dimensions dynamically based on measured content
  offCanvas.width = maxWidth + 50; // Add some padding to prevent clipping
  offCanvas.height = totalTextHeight;

  // Clear the off-screen canvas before drawing
  offCtx.clearRect(0, 0, offCanvas.width, offCanvas.height);
  offCtx.font = `${config.fontSize}px Arial, sans-serif`; // Re-set font after canvas resize
  offCtx.textBaseline = "top";
  offCtx.fillStyle = "black";

  // Draw each line onto the off-screen canvas
  lines.forEach((line, index) => {
    const lineWidth = offCtx.measureText(line).width;
    const lineX = (offCanvas.width - lineWidth) / 2; // Center each line horizontally
    const lineY = index * config.lineHeight; // Position lines vertically
    offCtx.fillText(line, lineX, lineY);
  });

  const imageData = offCtx.getImageData(0, 0, offCanvas.width, offCanvas.height);
  const points = [];

  // Calculate the overall offset to center the entire block of text on the main canvas
  const offsetX = canvas.width / 2 - offCanvas.width / 2;
  const offsetY = canvas.height / 2 - offCanvas.height / 2;

  for (let y = 0; y < offCanvas.height; y += config.pointSpacing) {
    for (let x = 0; x < offCanvas.width; x += config.pointSpacing) {
      const i = (y * offCanvas.width + x) * 4;
      if (imageData.data[i + 3] > 128) { // Check alpha channel for pixel presence
        points.push({ x: x + offsetX, y: y + offsetY });
      }
    }
  }
  cachedTargetPoints[text] = points;
  return points;
}

// Function to calculate text center
function calculateTextCenter() {
  const targets = cachedTargetPoints[config.textPhrases[currentPhraseIndex]];
  if (!targets || targets.length === 0) return { x: canvas.width / 2, y: canvas.height / 2 };

  // Calculate average of all points
  let sumX = 0, sumY = 0;
  targets.forEach(point => {
    sumX += point.x;
    sumY += point.y;
  });

  return {
    x: sumX / targets.length,
    y: sumY / targets.length
  };
}

// Function to update mouse radius based on proximity to text center
function updateMouseRadius() {
  if (mouse.x === null || mouse.y === null) {
    mouse.radius = config.mouseRadiusDefault;
    return;
  }

  // Calculate distance to text center
  const dx = mouse.x - textCenter.x;
  const dy = mouse.y - textCenter.y;
  const distanceToCenter = Math.sqrt(dx * dx + dy * dy);

  // Scale radius based on distance to center (closer = larger radius)
  if (distanceToCenter <= config.mouseProximityRange) {
    // Linear interpolation between max and min radius
    const t = 1 - (distanceToCenter / config.mouseProximityRange);
    mouse.radius = config.mouseRadiusMin + t * (config.mouseRadiusMax - config.mouseRadiusMin);
  } else {
    // Beyond the range, use minimum radius
    mouse.radius = config.mouseRadiusMin;
  }
}

function initializeOrUpdateParticles() {
  // Pre-calculate and cache all target points initially
  config.textPhrases.forEach(phrase => getTargetPoints(phrase));

  const currentTargets = cachedTargetPoints[config.textPhrases[currentPhraseIndex]];
  const nextTargets = cachedTargetPoints[config.textPhrases[nextPhraseIndex]];

  // Determine the maximum number of particles needed across all phrases
  const maxParticlesNeeded = Math.max(...config.textPhrases.map(phrase => cachedTargetPoints[phrase].length));

  // Add new particles if needed
  while (particles.length < maxParticlesNeeded) {
    const initialHome = currentTargets[0] || {x: canvas.width / 2, y: canvas.height / 2};
    particles.push(new Particle(initialHome.x, initialHome.y, initialHome.x, initialHome.y));
  }

  // Update existing particles' home and nextHome positions based on current and next text
  particles.forEach((p, i) => {
    // Current home position
    if (i < currentTargets.length) {
      p.homeX = currentTargets[i].x;
      p.homeY = currentTargets[i].y;
      p.isUsedInCurrentPhrase = true;
    } else {
      // If the current text is shorter, assign excess particles to random positions across the canvas
      p.homeX = Math.random() * canvas.width;
      p.homeY = Math.random() * canvas.height;
      p.isUsedInCurrentPhrase = false;
    }

    // Next home position
    if (i < nextTargets.length) {
      p.nextHomeX = nextTargets[i].x;
      p.nextHomeY = nextTargets[i].y;
      p.isUsedInNextPhrase = true;
    } else {
      // If the next text is shorter, assign excess particles to random positions
      p.nextHomeX = Math.random() * canvas.width;
      p.nextHomeY = Math.random() * canvas.height;
      p.isUsedInNextPhrase = false;
    }

    // Set colors
    p.baseColor = [...colorSchemes[currentColorScheme].base];
    p.activeColor = [...colorSchemes[currentColorScheme].active];
    p.nextBaseColor = [...colorSchemes[nextColorScheme].base];
    p.nextActiveColor = [...colorSchemes[nextColorScheme].active];

    // Reset particle specific transition state
    p.reset();

    // FIXED: Force proper size assignment after reset
    p.randomSizeAssigned = false;
    if (p.isUsedInCurrentPhrase) {
      if (config.randomizeActiveParticleSize) {
        p.targetSize = Math.random() * (config.maxParticleSize - config.minParticleSize) + config.minParticleSize;
        p.size = p.targetSize; // Set size immediately instead of transitioning
        p.randomSizeAssigned = true;
      } else {
        p.targetSize = config.maxParticleSize;
        p.size = p.targetSize;
      }
    } else {
      p.targetSize = config.minParticleSize;
      p.size = p.targetSize;
    }
  });

  // Calculate text center
  textCenter = calculateTextCenter();
}

function startTransition() {
  if (isTransitioning) return;

  const now = Date.now();
  if (now - lastTransitionTime < config.transitionCooldown) return;

  lastTransitionTime = now;
  isTransitioning = true;
  transitionProgress = 0;

  // Prepare next text positions by calculating the targets for the next phrase
  nextPhraseIndex = (currentPhraseIndex + 1) % config.textPhrases.length;
  const nextTargets = cachedTargetPoints[config.textPhrases[nextPhraseIndex]];

  // Update next color scheme
  nextColorScheme = (currentColorScheme + 1) % colorSchemes.length;

  // Update particles with their new target positions and colors
  particles.forEach((p, i) => {
    if (i < nextTargets.length) {
      p.setNextPosition(nextTargets[i].x, nextTargets[i].y);
      p.isUsedInNextPhrase = true;
    } else {
      // For particles that won't be part of the next text, set them to random positions
      p.setNextPosition(Math.random() * canvas.width, Math.random() * canvas.height);
      p.isUsedInNextPhrase = false;
    }
    p.setNextColors(
      colorSchemes[nextColorScheme].base,
      colorSchemes[nextColorScheme].active
    );
  });
}

function endTransition() {
  isTransitioning = false;
  currentPhraseIndex = nextPhraseIndex;
  currentColorScheme = nextColorScheme;

  // Commit the transition for all particles
  particles.forEach(p => p.commitTransition());

  // After transition, re-evaluate target points for the *new* next phrase
  const nextNextPhraseIndex = (currentPhraseIndex + 1) % config.textPhrases.length;
  const nextNextTargets = cachedTargetPoints[config.textPhrases[nextNextPhraseIndex]];
  const nextNextColorScheme = (currentColorScheme + 1) % colorSchemes.length;

  particles.forEach((p, i) => {
      if (i < nextNextTargets.length) {
          // This particle will be part of the *next* next phrase
          p.nextHomeX = nextNextTargets[i].x;
          p.nextHomeY = nextNextTargets[i].y;
          p.isUsedInNextPhrase = true;
      } else {
          // This particle won't be part of the *next* next phrase, set to random position
          p.nextHomeX = Math.random() * canvas.width;
          p.nextHomeY = Math.random() * canvas.height;
          p.isUsedInNextPhrase = false;
      }

      // Update next colors
      p.nextBaseColor = [...colorSchemes[nextNextColorScheme].base];
      p.nextActiveColor = [...colorSchemes[nextNextColorScheme].active];
  });

  // Update text center after transition
  textCenter = calculateTextCenter();
}

function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Update mouse radius based on distance to text center
  updateMouseRadius();

  affectedParticlesCount = 0;
  particles.forEach(p => {
    if (p.isAffectedByMouse) affectedParticlesCount++;
  });

  if (!isTransitioning && affectedParticlesCount > config.mouseTransitionThreshold) {
    startTransition();
  }

  if (isTransitioning) {
    transitionProgress += 0.01;
    if (transitionProgress >= 1.5) {
      endTransition();
    }
  }

  particles.forEach(p => p.update());

  // DEBUG: Draw text center point and active mouse radius
  if (config.debug) {
    ctx.beginPath();
    ctx.arc(textCenter.x, textCenter.y, 5, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(255, 0, 0, 0.8)";
    ctx.fill();

    if (mouse.x !== null && mouse.y !== null) {
      ctx.beginPath();
      ctx.arc(mouse.x, mouse.y, mouse.radius, 0, Math.PI * 2);
      ctx.strokeStyle = "rgba(255, 0, 0, 0.3)";
      ctx.stroke();
    }
  }

  requestAnimationFrame(animate);
}

// Event listeners
window.addEventListener("mousemove", (e) => {
  mouse.x = e.clientX;
  mouse.y = e.clientY;
});

window.addEventListener("mouseout", () => {
  mouse.x = null;
  mouse.y = null;
});

window.addEventListener("resize", () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // Clear the cache so text positions will be recalculated
  Object.keys(cachedTargetPoints).forEach(key => {
    delete cachedTargetPoints[key];
  });

  // Re-initialize/update particle positions on resize
  initializeOrUpdateParticles();
});

// Key press to toggle effects
window.addEventListener("keydown", (e) => {
  if (e.key === "1") {
    config.easingFunction = "easeOutCubic";
    console.log("Easing: easeOutCubic");
  } else if (e.key === "2") {
    config.easingFunction = "easeInOutQuint";
    console.log("Easing: easeInOutQuint");
  } else if (e.key === "3") {
    config.easingFunction = "easeOutElastic";
    console.log("Easing: easeOutElastic");
  } else if (e.key === "4") {
    config.easingFunction = "easeInOutSine";
    console.log("Easing: easeInOutSine");
  } else if (e.key === "p") {
    // Change this to cycle between path types
    const pathTypes = ["figure8", "arc", "bezier"];
    const currentIndex = pathTypes.indexOf(config.pathType);
    config.pathType = pathTypes[(currentIndex + 1) % pathTypes.length];
    particles.forEach(p => p.pathType = config.pathType);
    console.log("Path Type:", config.pathType);
  } else if (e.key === "c") {
    config.colorTransition = !config.colorTransition;
    console.log("Color Transition:", config.colorTransition);
  } else if (e.key === "g") {
    config.groupTransition = !config.groupTransition;
    console.log("Group Transition:", config.groupTransition);
  } else if (e.key === "r") {
    config.randomizeActiveParticleSize = !config.randomizeActiveParticleSize;
    console.log("Random Particle Sizes:", config.randomizeActiveParticleSize);
  } else if (e.key === "f") {
    // NEW: Toggle figure8 variation
    config.figure8Variation = !config.figure8Variation;
    console.log("Figure-8 Variation:", config.figure8Variation);
  } else if (e.key === "w") {
    // Toggle wiggle effect
    config.wiggleEnabled = !config.wiggleEnabled;
    console.log("Wiggle Effect:", config.wiggleEnabled);
  } else if (e.key === "d") {
    // Toggle debug visualization
    config.debug = !config.debug;
    console.log("Debug Mode:", config.debug);
  } else if (e.key === " ") {
    startTransition(); // Space bar to force transition
  }

  // NEW: Size adjustment for figure-8
  else if (e.key === "+") {
    config.figure8Size += 10;
    console.log("Figure-8 Size:", config.figure8Size);
  } else if (e.key === "-") {
    config.figure8Size = Math.max(10, config.figure8Size - 10);
    console.log("Figure-8 Size:", config.figure8Size);
  }
});

// Initialize debug flag
config.debug = false;

// Start the animation only after fonts are loaded and particles are set up
document.fonts.ready.then(() => {
  initializeOrUpdateParticles();
  animate();
});
</script>
</body>
</html>
